
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">



<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <script type="text/javascript">

      var _gaq = _gaq || [];
      _gaq.push(['_setAccount', 'UA-19801227-1']);
      _gaq.push(['_trackPageview']);

      (function() {
        var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
        ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
        var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
      })();
    </script>
    <title>prody.sequence.analysis &mdash; RuleBender</title>
    <link rel="stylesheet" href="../../../_static/css/basic.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/css/pygments.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/css/bootswatch-united.min.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/css/prodydocs.css" type="text/css" />
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  false
      };
    </script>
    <script type="text/javascript" src="../../../_static/js/jquery-2.0.0.min.js"></script>
    <script type="text/javascript" src="../../../_static/js/bootstrap.min.js"></script>
    <script type="text/javascript" src="../../../_static/js/zeroclipboard.min.js"></script>
    <script type="text/javascript" src="../../../_static/js/copybutton.js"></script>
    <script type="text/javascript" src="../../../_static/js/prodydocs.js"></script>
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>

  </head>
  <body data-spy="scroll" data-target="#localtoc" data-offset="190">

<div class="container">
  <div class="row">
    <div class="span12">
      <a href="../../../index.html">
        <img src="../../../_static/logo.png" alt="ProDy logo" id="logo" />
      </a>
    </div>
    <div class="span12">
      <div class="subnav">
        <ul class="nav nav-pills">
        <li class="pull-right">
          <a href="../../../genindex.html" title="General Index"
             accesskey="I">index</a>
          </li>
        <li class="pull-right">
          <a href="../../../py-modindex.html" title="Python Module Index"
             >modules</a>
          </li>
        <li><a href="../../../index.html">Home  &raquo;</a></li>
          <li><a href="../../index.html" >Module code &raquo;</a></li>
          <li><a href="../../prody.html" accesskey="U">prody &raquo;</a></li> 
        </ul>
      </div>
    </div>
  </div>

  <div class="content">
  <div class="row">
    <div class="span3">
      <div id="sidebar" style="width: 220px">
        <div class="accordion" id="accordion2">
  <div id="searchbox" class="accordion-group">
    <div class="accordion-heading">
      <a class="accordion-toggle" data-toggle="collapse" data-parent="#accordion2" href="#collapseToolbox">
        <strong>Toolbox</strong>
      </a>
    </div>
<!--     <div id="collapseToolbox" class="accordion-body collapse in">
      <div class="accordion-inner">
        <div id="showcodebuttons" style="margin-bottom: 10px">
          <p><small>Show code snippets for copying:</small></p>
          <div class="btn-group">
            <a href="#codemodal" role="button" data-toggle="modal" id="showcode" class="btn btn-primary btn-small">
              <i class="icon-fullscreen icon-white"></i> Show code</a>
            <a href="#codemodal" role="button" data-toggle="modal" id="withcomments" class="btn btn-primary btn-small">
              and output <i class="icon-comment icon-white"></i> </a>
          </div>
        </div> -->

        <p><small>Search terms or function by name:</small></p>
        <form class="form-search pull-right" action="../../../search.html" method="get">
          <div class="input-append">
            <input type="text" class="input-small search-query" name="q" class="span2">
            <button type="submit" class="btn btn-primary">Go</button>
          </div>
          <input type="hidden" name="check_keywords" value="yes" />
          <input type="hidden" name="area" value="default" />
        </form>
      </div>
    </div>
  </div>  <div class="accordion-group">
    <div class="accordion-heading">
      <a class="accordion-toggle" data-toggle="collapse" data-parent="#accordion2" href="#collapseReleaseNotes">
        <strong>Release Notes</strong>
      </a>
    </div>
    <div id="collapseReleaseNotes" class="accordion-body collapse in">
      <div class="accordion-inner">
        <p><small><strong>v1</strong> series come with new and improved sequence, structure, and dynamics analysis
features. See <a href="../../../manual/release/index.html">release notes</a> for details.
        </small></p>
      </div>
    </div>
  </div>  <div class="accordion-group">
    <div class="accordion-heading">
      <a class="accordion-toggle" data-toggle="collapse" data-parent="#accordion2" href="#collapseHowToCite">
        <strong>How to Cite</strong>
      </a>
    </div>
    <div id="collapseHowToCite" class="accordion-body collapse in">
      <div class="accordion-inner">
        <p><small>
          Bakan A, Meireles LM, Bahar I
          <a class="reference external" href="http://bioinformatics.oxfordjournals.org/content/27/11/1575" target="_blank">
          <i>ProDy</i>: Protein Dynamics Inferred from Theory and Experiments</a> <br/>
          <em>Bioinformatics</em> <strong>2011</strong> 27(11):1575-1577.
        </small></p>
      </div>
    </div>
  </div>
        </div>
      </div>
    </div>
    <div class="span9 body">
    
  <h1>Source code for prody.sequence.analysis</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;This module defines MSA analysis functions.&quot;&quot;&quot;</span>

<span class="n">__author__</span> <span class="o">=</span> <span class="s1">&#39;Anindita Dutta, Ahmet Bakan, Wenzhi Mao&#39;</span>

<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">dtype</span><span class="p">,</span> <span class="n">zeros</span><span class="p">,</span> <span class="n">empty</span><span class="p">,</span> <span class="n">ones</span>
<span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">indices</span><span class="p">,</span> <span class="n">tril_indices</span>
<span class="kn">from</span> <span class="nn">prody</span> <span class="kn">import</span> <span class="n">LOGGER</span>

<span class="n">__all__</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;calcShannonEntropy&#39;</span><span class="p">,</span> <span class="s1">&#39;buildMutinfoMatrix&#39;</span><span class="p">,</span> <span class="s1">&#39;calcMSAOccupancy&#39;</span><span class="p">,</span>
           <span class="s1">&#39;applyMutinfoCorr&#39;</span><span class="p">,</span> <span class="s1">&#39;applyMutinfoNorm&#39;</span><span class="p">,</span> <span class="s1">&#39;calcRankorder&#39;</span><span class="p">,</span>
           <span class="s1">&#39;buildSeqidMatrix&#39;</span><span class="p">,</span> <span class="s1">&#39;uniqueSequences&#39;</span><span class="p">,</span> <span class="s1">&#39;buildOMESMatrix&#39;</span><span class="p">,</span>
           <span class="s1">&#39;buildSCAMatrix&#39;</span><span class="p">,</span> <span class="s1">&#39;buildDirectInfoMatrix&#39;</span><span class="p">,</span> <span class="s1">&#39;calcMeff&#39;</span><span class="p">,</span> <span class="s1">&#39;buildPCMatrix&#39;</span><span class="p">]</span>


<span class="n">doc_turbo</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>

<span class="s2">    By default, *turbo* mode, which uses memory as large as the MSA array</span>
<span class="s2">    itself but runs four to five times faster, will be used.  If memory</span>
<span class="s2">    allocation fails, the implementation will fall back to slower and</span>
<span class="s2">    memory efficient mode.&quot;&quot;&quot;</span>


<span class="k">def</span> <span class="nf">getMSA</span><span class="p">(</span><span class="n">msa</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns MSA character array.&quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">msa</span> <span class="o">=</span> <span class="n">msa</span><span class="o">.</span><span class="n">_getArray</span><span class="p">()</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">pass</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">dtype_</span><span class="p">,</span> <span class="n">ndim</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">msa</span><span class="o">.</span><span class="n">dtype</span><span class="p">,</span> <span class="n">msa</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">msa</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;msa must be an MSA instance or a 2D character array&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">dtype_</span> <span class="o">!=</span> <span class="n">dtype</span><span class="p">(</span><span class="s1">&#39;|S1&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;msa must be an MSA instance or a 2D character array&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">msa</span>


<div class="viewcode-block" id="calcShannonEntropy"><a class="viewcode-back" href="../../../manual/reference/sequence/analysis.html#prody.sequence.analysis.calcShannonEntropy">[docs]</a><span class="k">def</span> <span class="nf">calcShannonEntropy</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">ambiguity</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">omitgaps</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns Shannon entropy array calculated for *msa*, which may be</span>
<span class="sd">    an :class:`.MSA` instance or a 2D Numpy character array.  Implementation</span>
<span class="sd">    is case insensitive and handles ambiguous amino acids as follows:</span>

<span class="sd">      * **B** (Asx) count is allocated to *D* (Asp) and *N* (Asn)</span>
<span class="sd">      * **Z** (Glx) count is allocated to *E* (Glu) and *Q* (Gln)</span>
<span class="sd">      * **J** (Xle) count is allocated to *I* (Ile) and *L* (Leu)</span>
<span class="sd">      * **X** (Xaa) count is allocated to the twenty standard amino acids</span>

<span class="sd">    Selenocysteine (**U**, Sec) and pyrrolysine (**O**, Pyl) are considered</span>
<span class="sd">    as distinct amino acids.  When *ambiguity* is set **False**, all alphabet</span>
<span class="sd">    characters as considered as distinct types.</span>

<span class="sd">    All non-alphabet characters are considered as gaps, and they are handled</span>
<span class="sd">    in two ways:</span>

<span class="sd">      * non-existent, the probability of observing amino acids in a given</span>
<span class="sd">        column is adjusted, by default</span>
<span class="sd">      * as a distinct character with its own probability, when *omitgaps* is</span>
<span class="sd">        **False**&quot;&quot;&quot;</span>

    <span class="n">msa</span> <span class="o">=</span> <span class="n">getMSA</span><span class="p">(</span><span class="n">msa</span><span class="p">)</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">msa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="k">if</span> <span class="n">msa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">100</span><span class="p">:</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;SCA performs the best with higher number of sequences, and &#39;</span>
                       <span class="s1">&#39;minimal number of sequences is recommended as 100.&#39;</span><span class="p">)</span>
    <span class="n">entropy</span> <span class="o">=</span> <span class="n">empty</span><span class="p">(</span><span class="n">length</span><span class="p">,</span> <span class="nb">float</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">.msatools</span> <span class="kn">import</span> <span class="n">msaentropy</span>
    <span class="k">return</span> <span class="n">msaentropy</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">entropy</span><span class="p">,</span>
                      <span class="n">ambiguity</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">ambiguity</span><span class="p">),</span> <span class="n">omitgaps</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">omitgaps</span><span class="p">))</span></div>


<div class="viewcode-block" id="buildMutinfoMatrix"><a class="viewcode-back" href="../../../manual/reference/sequence/analysis.html#prody.sequence.analysis.buildMutinfoMatrix">[docs]</a><span class="k">def</span> <span class="nf">buildMutinfoMatrix</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">ambiguity</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">turbo</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns mutual information matrix calculated for *msa*, which may be an</span>
<span class="sd">    :class:`.MSA` instance or a 2D Numpy character array.  Implementation</span>
<span class="sd">    is case insensitive and handles ambiguous amino acids as follows:</span>

<span class="sd">      * **B** (Asx) count is allocated to *D* (Asp) and *N* (Asn)</span>
<span class="sd">      * **Z** (Glx) count is allocated to *E* (Glu) and *Q* (Gln)</span>
<span class="sd">      * **J** (Xle) count is allocated to *I* (Ile) and *L* (Leu)</span>
<span class="sd">      * **X** (Xaa) count is allocated to the twenty standard amino acids</span>
<span class="sd">      * Joint probability of observing a pair of ambiguous amino acids is</span>
<span class="sd">        allocated to all potential combinations, e.g. probability of **XX**</span>
<span class="sd">        is allocated to 400 combinations of standard amino acids, similarly</span>
<span class="sd">        probability of **XB** is allocated to 40 combinations of *D* and *N*</span>
<span class="sd">        with the standard amino acids.</span>

<span class="sd">    Selenocysteine (**U**, Sec) and pyrrolysine (**O**, Pyl) are considered</span>
<span class="sd">    as distinct amino acids.  When *ambiguity* is set **False**, all alphabet</span>
<span class="sd">    characters as considered as distinct types.  All non-alphabet characters</span>
<span class="sd">    are considered as gaps.</span>

<span class="sd">    Mutual information matrix can be normalized or corrected using</span>
<span class="sd">    :func:`applyMINormalization` and :func:`applyMICorrection` methods,</span>
<span class="sd">    respectively.  Normalization by joint entropy can performed using this</span>
<span class="sd">    function with *norm* option set **True**.&quot;&quot;&quot;</span>

    <span class="n">msa</span> <span class="o">=</span> <span class="n">getMSA</span><span class="p">(</span><span class="n">msa</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">.msatools</span> <span class="kn">import</span> <span class="n">msamutinfo</span>
    <span class="n">LOGGER</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;_mutinfo&#39;</span><span class="p">)</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">msa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">mutinfo</span> <span class="o">=</span> <span class="n">empty</span><span class="p">((</span><span class="n">length</span><span class="p">,</span> <span class="n">length</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">mutinfo</span> <span class="o">=</span> <span class="n">msamutinfo</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">mutinfo</span><span class="p">,</span>
                         <span class="n">ambiguity</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">ambiguity</span><span class="p">),</span> <span class="n">turbo</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">turbo</span><span class="p">),</span>
                         <span class="n">norm</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;norm&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)),</span>
                         <span class="n">debug</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;debug&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)))</span>
    <span class="n">LOGGER</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s1">&#39;Mutual information matrix was calculated in </span><span class="si">%.2f</span><span class="s1">s.&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;_mutinfo&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mutinfo</span></div>

<span class="n">buildMutinfoMatrix</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">+=</span> <span class="n">doc_turbo</span>


<div class="viewcode-block" id="calcMSAOccupancy"><a class="viewcode-back" href="../../../manual/reference/sequence/analysis.html#prody.sequence.analysis.calcMSAOccupancy">[docs]</a><span class="k">def</span> <span class="nf">calcMSAOccupancy</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">occ</span><span class="o">=</span><span class="s1">&#39;res&#39;</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="bp">False</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns occupancy array calculated for residue positions (default,</span>
<span class="sd">    ``&#39;res&#39;`` or ``&#39;col&#39;`` for *occ*) or sequences (``&#39;seq&#39;`` or ``&#39;row&#39;``</span>
<span class="sd">    for *occ*) of *msa*, which may be an :class:`.MSA` instance or a 2D</span>
<span class="sd">    NumPy character array.  By default, occupancy [0-1] will be calculated.</span>
<span class="sd">    If *count* is **True**, count of non-gap characters will be returned.</span>
<span class="sd">    Implementation is case insensitive.&quot;&quot;&quot;</span>

    <span class="kn">from</span> <span class="nn">.msatools</span> <span class="kn">import</span> <span class="n">msaocc</span>

    <span class="n">msa</span> <span class="o">=</span> <span class="n">getMSA</span><span class="p">(</span><span class="n">msa</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">dim</span> <span class="o">=</span> <span class="n">occ</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;res&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">occ</span><span class="o">.</span><span class="n">startswith</span><span class="p">(</span><span class="s1">&#39;col&#39;</span><span class="p">)</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;occ must be a string&#39;</span><span class="p">)</span>
    <span class="n">occ</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">(</span><span class="n">msa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="nb">int</span><span class="p">(</span><span class="n">dim</span><span class="p">)],</span> <span class="nb">float</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">msaocc</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">occ</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">count</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">count</span><span class="p">))</span></div>


<div class="viewcode-block" id="applyMutinfoNorm"><a class="viewcode-back" href="../../../manual/reference/sequence/analysis.html#prody.sequence.analysis.applyMutinfoNorm">[docs]</a><span class="k">def</span> <span class="nf">applyMutinfoNorm</span><span class="p">(</span><span class="n">mutinfo</span><span class="p">,</span> <span class="n">entropy</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="s1">&#39;sument&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Apply one of the normalizations discussed in [MLC05]_ to *mutinfo*</span>
<span class="sd">    matrix.  *norm* can be one of the following:</span>

<span class="sd">      * ``&#39;sument&#39;``: :math:`H(X) + H(Y)`, sum of entropy of columns</span>
<span class="sd">      * ``&#39;minent&#39;``: :math:`min\{H(X), H(Y)\}`, minimum entropy</span>
<span class="sd">      * ``&#39;maxent&#39;``: :math:`max\{H(X), H(Y)\}`, maximum entropy</span>
<span class="sd">      * ``&#39;mincon&#39;``: :math:`min\{H(X|Y), H(Y|X)\}`, minimum conditional</span>
<span class="sd">         entropy</span>
<span class="sd">      * ``&#39;maxcon&#39;``: :math:`max\{H(X|Y), H(Y|X)\}`, maximum conditional</span>
<span class="sd">         entropy</span>

<span class="sd">    where :math:`H(X)` is the entropy of a column, and</span>
<span class="sd">    :math:`H(X|Y) = H(X) - MI(X, Y)`.  Normalization with joint entropy, i.e.</span>
<span class="sd">    :math:`H(X, Y)`, can be done using :func:`.buildMutinfoMatrix` *norm*</span>
<span class="sd">    argument.</span>

<span class="sd">    .. [MLC05] Martin LC, Gloor GB, Dunn SD, Wahl LM. Using information theory</span>
<span class="sd">       to search for co-evolving residues in proteins. *Bioinformatics*</span>
<span class="sd">       **2005** 21(22):4116-4124.&quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">ndim</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">mutinfo</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">mutinfo</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;mutinfo must be a 2D square array&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;mutinfo must be a 2D square array&#39;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">ndim</span><span class="p">,</span> <span class="n">shapent</span> <span class="o">=</span> <span class="n">entropy</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">entropy</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;entropy must be a numpy array&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ndim</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;entropy must be a 1D array&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">shapent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;shape of mutinfo and entropy does not match&#39;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">sw</span> <span class="o">=</span> <span class="n">norm</span><span class="o">.</span><span class="n">startswith</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;norm must be a string&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">sw</span><span class="p">(</span><span class="s1">&#39;sument&#39;</span><span class="p">):</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i_val</span><span class="p">,</span> <span class="n">j_val</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="n">i_val</span> <span class="o">+</span> <span class="n">j_val</span>

    <span class="k">elif</span> <span class="n">sw</span><span class="p">(</span><span class="s1">&#39;minent&#39;</span><span class="p">):</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i_val</span><span class="p">,</span> <span class="n">j_val</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="n">i_val</span><span class="p">,</span> <span class="n">j_val</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">sw</span><span class="p">(</span><span class="s1">&#39;maxent&#39;</span><span class="p">):</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i_val</span><span class="p">,</span> <span class="n">j_val</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">i_val</span><span class="p">,</span> <span class="n">j_val</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">sw</span><span class="p">(</span><span class="s1">&#39;mincon&#39;</span><span class="p">):</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i_val</span><span class="p">,</span> <span class="n">j_val</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">min</span><span class="p">(</span><span class="n">i_val</span> <span class="o">-</span> <span class="n">val</span><span class="p">,</span> <span class="n">j_val</span> <span class="o">-</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">sw</span><span class="p">(</span><span class="s1">&#39;maxcon&#39;</span><span class="p">):</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="k">lambda</span> <span class="n">i_val</span><span class="p">,</span> <span class="n">j_val</span><span class="p">,</span> <span class="n">val</span><span class="p">:</span> <span class="nb">max</span><span class="p">(</span><span class="n">i_val</span> <span class="o">-</span> <span class="n">val</span><span class="p">,</span> <span class="n">j_val</span> <span class="o">-</span> <span class="n">val</span><span class="p">)</span>

    <span class="k">elif</span> <span class="n">sw</span><span class="p">(</span><span class="s1">&#39;joint&#39;</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;for joint entropy normalization, use &#39;</span>
                         <span class="s1">&#39;buildMutinfoMatrix function&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;norm={0} is not a valid normalization type&#39;</span>
                         <span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">norm</span><span class="p">))</span>

    <span class="n">mi</span> <span class="o">=</span> <span class="n">mutinfo</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">i_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">entropy</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">j_val</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">entropy</span><span class="p">):</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">mi</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span>
            <span class="n">div</span> <span class="o">=</span> <span class="n">norm</span><span class="p">(</span><span class="n">i_val</span><span class="p">,</span> <span class="n">j_val</span><span class="p">,</span> <span class="n">val</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">div</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">mi</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">mi</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">/=</span> <span class="n">div</span>

    <span class="k">return</span> <span class="n">mi</span></div>


<div class="viewcode-block" id="applyMutinfoCorr"><a class="viewcode-back" href="../../../manual/reference/sequence/analysis.html#prody.sequence.analysis.applyMutinfoCorr">[docs]</a><span class="k">def</span> <span class="nf">applyMutinfoCorr</span><span class="p">(</span><span class="n">mutinfo</span><span class="p">,</span> <span class="n">corr</span><span class="o">=</span><span class="s1">&#39;prod&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a copy of *mutinfo* array after average product correction</span>
<span class="sd">    (default) or average sum correction is applied.  See [DSD08]_ for details.</span>

<span class="sd">    .. [DSD08] Dunn SD, Wahl LM, Gloor GB. Mutual information without the</span>
<span class="sd">       influence of phylogeny or entropy dramatically improves residue</span>
<span class="sd">       contact prediction. *Bioinformatics* **2008** 24(3):333-340.&quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">ndim</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">mutinfo</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">mutinfo</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;mutinfo must be a 2D square array&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span> <span class="ow">or</span> <span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;mutinfo must be a 2D square array&#39;</span><span class="p">)</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">sw</span> <span class="o">=</span> <span class="n">corr</span><span class="o">.</span><span class="n">startswith</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;correction must be a string&#39;</span><span class="p">)</span>

    <span class="n">avg_mipos</span> <span class="o">=</span> <span class="n">mutinfo</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">/</span> <span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">avg_mi</span> <span class="o">=</span> <span class="n">avg_mipos</span><span class="o">.</span><span class="n">mean</span><span class="p">()</span>

    <span class="n">mi</span> <span class="o">=</span> <span class="n">mutinfo</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">sw</span><span class="p">(</span><span class="s1">&#39;prod&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">sw</span><span class="p">(</span><span class="s1">&#39;apc&#39;</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">i_avg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">avg_mipos</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">j_avg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">avg_mipos</span><span class="p">):</span>
                <span class="n">mi</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="p">(</span><span class="n">i_avg</span> <span class="o">*</span> <span class="n">j_avg</span><span class="p">)</span> <span class="o">/</span> <span class="n">avg_mi</span>
    <span class="k">elif</span> <span class="n">sw</span><span class="p">(</span><span class="s1">&#39;sum&#39;</span><span class="p">)</span> <span class="ow">or</span> <span class="n">sw</span><span class="p">(</span><span class="s1">&#39;asc&#39;</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">i_avg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">avg_mipos</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">j</span><span class="p">,</span> <span class="n">j_avg</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">avg_mipos</span><span class="p">):</span>
                <span class="n">mi</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="n">j</span><span class="p">]</span> <span class="o">-=</span> <span class="n">i_avg</span> <span class="o">+</span> <span class="n">j_avg</span> <span class="o">-</span> <span class="n">avg_mi</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;correction must be prod or sum, not &#39;</span> <span class="o">+</span> <span class="n">corr</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">mi</span></div>


<div class="viewcode-block" id="buildSeqidMatrix"><a class="viewcode-back" href="../../../manual/reference/sequence/analysis.html#prody.sequence.analysis.buildSeqidMatrix">[docs]</a><span class="k">def</span> <span class="nf">buildSeqidMatrix</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">turbo</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns sequence identity matrix for *msa*.&quot;&quot;&quot;</span>

    <span class="n">msa</span> <span class="o">=</span> <span class="n">getMSA</span><span class="p">(</span><span class="n">msa</span><span class="p">)</span>

    <span class="n">LOGGER</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;_seqid&#39;</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">.seqtools</span> <span class="kn">import</span> <span class="n">msaeye</span>

    <span class="n">dim</span> <span class="o">=</span> <span class="n">msa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">seqid</span> <span class="o">=</span> <span class="n">msaeye</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">ones</span><span class="p">((</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">),</span> <span class="nb">float</span><span class="p">),</span> <span class="n">turbo</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">turbo</span><span class="p">))</span>

    <span class="n">LOGGER</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s1">&#39;Sequence identity matrix was calculated in </span><span class="si">%.2f</span><span class="s1">s.&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;_seqid&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">seqid</span></div>

<span class="n">buildSeqidMatrix</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">+=</span> <span class="n">doc_turbo</span>


<div class="viewcode-block" id="uniqueSequences"><a class="viewcode-back" href="../../../manual/reference/sequence/analysis.html#prody.sequence.analysis.uniqueSequences">[docs]</a><span class="k">def</span> <span class="nf">uniqueSequences</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">seqid</span><span class="o">=</span><span class="mf">0.98</span><span class="p">,</span> <span class="n">turbo</span><span class="o">=</span><span class="bp">True</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns a boolean array marking unique sequences in *msa*.  A sequence</span>
<span class="sd">    sharing sequence identity of *sqid* or more with another sequence coming</span>
<span class="sd">    before itself in *msa* will have a **False** value in the array.&quot;&quot;&quot;</span>

    <span class="n">msa</span> <span class="o">=</span> <span class="n">getMSA</span><span class="p">(</span><span class="n">msa</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">.seqtools</span> <span class="kn">import</span> <span class="n">msaeye</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">seqid</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;seqid must satisfy 0 &lt; seqid &lt;= 1&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">msaeye</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">zeros</span><span class="p">(</span><span class="n">msa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">bool</span><span class="p">),</span>
                  <span class="n">unique</span><span class="o">=</span><span class="n">seqid</span><span class="p">,</span> <span class="n">turbo</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">turbo</span><span class="p">))</span></div>

<span class="n">uniqueSequences</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">+=</span> <span class="n">doc_turbo</span>


<div class="viewcode-block" id="calcRankorder"><a class="viewcode-back" href="../../../manual/reference/sequence/analysis.html#prody.sequence.analysis.calcRankorder">[docs]</a><span class="k">def</span> <span class="nf">calcRankorder</span><span class="p">(</span><span class="n">matrix</span><span class="p">,</span> <span class="n">zscore</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returnss indices of elements and corresponding values sorted in</span>
<span class="sd">    descending order, if *descend* is **True** (default). Can apply a zscore</span>
<span class="sd">    normalization; by default along *axis* - 0 such that each column has</span>
<span class="sd">    mean=0 and std=1.  If *zcore* analysis is used, return value contains the</span>
<span class="sd">    zscores. If matrix is smymetric only lower triangle indices will be</span>
<span class="sd">    returned, with diagonal elements if *diag* is **True** (default).&quot;&quot;&quot;</span>

    <span class="k">try</span><span class="p">:</span>
        <span class="n">ndim</span><span class="p">,</span> <span class="n">shape</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">ndim</span><span class="p">,</span> <span class="n">matrix</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;matrix must be a 2D array&#39;</span><span class="p">)</span>

    <span class="k">if</span> <span class="n">ndim</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;matrix must be a 2D array&#39;</span><span class="p">)</span>

    <span class="n">threshold</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;thredhold&#39;</span><span class="p">,</span> <span class="mf">0.0001</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">symm</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">((</span><span class="n">matrix</span><span class="o">.</span><span class="n">transpose</span><span class="p">()</span> <span class="o">-</span> <span class="n">matrix</span><span class="p">)</span><span class="o">.</span><span class="n">max</span><span class="p">())</span> <span class="o">&lt;</span> <span class="n">threshold</span>
    <span class="k">except</span><span class="p">:</span>
        <span class="n">symm</span> <span class="o">=</span> <span class="bp">False</span>

    <span class="k">if</span> <span class="n">zscore</span><span class="p">:</span>
        <span class="n">axis</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">bool</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;axis&#39;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)))</span>
        <span class="n">matrix</span> <span class="o">=</span> <span class="p">(</span><span class="n">matrix</span> <span class="o">-</span> <span class="n">matrix</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">axis</span><span class="p">))</span> <span class="o">/</span> <span class="n">matrix</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">axis</span><span class="p">)</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Zscore normalization has been applied.&#39;</span><span class="p">)</span>

    <span class="n">descend</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;descend&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">symm</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">descend</span><span class="p">:</span>
            <span class="n">sorted_index</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sorted_index</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="n">shape</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">sorted_index</span><span class="p">]</span>
        <span class="n">column</span> <span class="o">=</span> <span class="n">indices</span><span class="p">(</span><span class="n">shape</span><span class="p">)[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">flatten</span><span class="p">()[</span><span class="n">sorted_index</span><span class="p">]</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Matrix is symmetric, only lower triangle indices &#39;</span>
                    <span class="s1">&#39;will be returned.&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;diag&#39;</span><span class="p">,</span> <span class="bp">True</span><span class="p">):</span>
            <span class="n">k</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">k</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">ind_row</span><span class="p">,</span> <span class="n">ind_column</span> <span class="o">=</span> <span class="n">tril_indices</span><span class="p">(</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">k</span><span class="o">=</span><span class="n">k</span><span class="p">)</span>
        <span class="n">matrix_lt</span> <span class="o">=</span> <span class="n">matrix</span><span class="p">[</span><span class="n">ind_row</span><span class="p">,</span> <span class="n">ind_column</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">descend</span><span class="p">:</span>
            <span class="n">sorted_index</span> <span class="o">=</span> <span class="n">matrix_lt</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">)[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">sorted_index</span> <span class="o">=</span> <span class="n">matrix_lt</span><span class="o">.</span><span class="n">argsort</span><span class="p">(</span><span class="n">axis</span><span class="o">=</span><span class="bp">None</span><span class="p">)</span>
        <span class="n">row</span> <span class="o">=</span> <span class="n">ind_row</span><span class="p">[</span><span class="n">sorted_index</span><span class="p">]</span>
        <span class="n">column</span> <span class="o">=</span> <span class="n">ind_column</span><span class="p">[</span><span class="n">sorted_index</span><span class="p">]</span>

    <span class="k">return</span> <span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">,</span> <span class="n">matrix</span><span class="p">[</span><span class="n">row</span><span class="p">,</span> <span class="n">column</span><span class="p">])</span></div>


<div class="viewcode-block" id="buildOMESMatrix"><a class="viewcode-back" href="../../../manual/reference/sequence/analysis.html#prody.sequence.analysis.buildOMESMatrix">[docs]</a><span class="k">def</span> <span class="nf">buildOMESMatrix</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">ambiguity</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="n">turbo</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns OMES (Observed Minus Expected Squared) covariance matrix</span>
<span class="sd">    calculated for *msa*, which may be an :class:`.MSA` instance or a 2D</span>
<span class="sd">    NumPy character array. OMES is defined as::</span>

<span class="sd">                        (N_OBS - N_EX)^2              (f_i,j - f_i * f_j)^2</span>
<span class="sd">      OMES_(i,j) = sum(------------------) = N * sum(-----------------------)</span>
<span class="sd">                             N_EX                           f_i * f_j</span>

<span class="sd">    Implementation is case insensitive and handles ambiguous amino acids</span>
<span class="sd">    as follows:</span>

<span class="sd">      * **B** (Asx) count is allocated to *D* (Asp) and *N* (Asn)</span>
<span class="sd">      * **Z** (Glx) count is allocated to *E* (Glu) and *Q* (Gln)</span>
<span class="sd">      * **J** (Xle) count is allocated to *I* (Ile) and *L* (Leu)</span>
<span class="sd">      * **X** (Xaa) count is allocated to the twenty standard amino acids</span>
<span class="sd">      * Joint probability of observing a pair of ambiguous amino acids is</span>
<span class="sd">        allocated to all potential combinations, e.g. probability of **XX**</span>
<span class="sd">        is allocated to 400 combinations of standard amino acids, similarly</span>
<span class="sd">        probability of **XB** is allocated to 40 combinations of *D* and *N*</span>
<span class="sd">        with the standard amino acids.</span>

<span class="sd">    Selenocysteine (**U**, Sec) and pyrrolysine (**O**, Pyl) are considered</span>
<span class="sd">    as distinct amino acids.  When *ambiguity* is set **False**, all alphabet</span>
<span class="sd">    characters as considered as distinct types.  All non-alphabet characters</span>
<span class="sd">    are considered as gaps.&quot;&quot;&quot;</span>

    <span class="n">msa</span> <span class="o">=</span> <span class="n">getMSA</span><span class="p">(</span><span class="n">msa</span><span class="p">)</span>

    <span class="kn">from</span> <span class="nn">.msatools</span> <span class="kn">import</span> <span class="n">msaomes</span>
    <span class="n">LOGGER</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;_omes&#39;</span><span class="p">)</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">msa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">omes</span> <span class="o">=</span> <span class="n">empty</span><span class="p">((</span><span class="n">length</span><span class="p">,</span> <span class="n">length</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">omes</span> <span class="o">=</span> <span class="n">msaomes</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">omes</span><span class="p">,</span> <span class="n">ambiguity</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">ambiguity</span><span class="p">),</span> <span class="n">turbo</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">turbo</span><span class="p">),</span>
                   <span class="n">debug</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">kwargs</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s1">&#39;debug&#39;</span><span class="p">,</span> <span class="bp">False</span><span class="p">)))</span>
    <span class="n">LOGGER</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s1">&#39;OMES matrix was calculated in </span><span class="si">%.2f</span><span class="s1">s.&#39;</span><span class="p">,</span>
                  <span class="s1">&#39;_omes&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">omes</span></div>

<span class="n">buildOMESMatrix</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">+=</span> <span class="n">doc_turbo</span>


<div class="viewcode-block" id="buildSCAMatrix"><a class="viewcode-back" href="../../../manual/reference/sequence/analysis.html#prody.sequence.analysis.buildSCAMatrix">[docs]</a><span class="k">def</span> <span class="nf">buildSCAMatrix</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">turbo</span><span class="o">=</span><span class="bp">True</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns SCA matrix calculated for *msa*, which may be an :class:`.MSA`</span>
<span class="sd">    instance or a 2D Numpy character array.</span>

<span class="sd">    Implementation is case insensitive and handles ambiguous amino acids</span>
<span class="sd">    as follows:</span>

<span class="sd">      * **B** (Asx) count is allocated to *D* (Asp) and *N* (Asn)</span>
<span class="sd">      * **Z** (Glx) count is allocated to *E* (Glu) and *Q* (Gln)</span>
<span class="sd">      * **J** (Xle) count is allocated to *I* (Ile) and *L* (Leu)</span>
<span class="sd">      * **X** (Xaa) count is allocated to the twenty standard amino acids</span>
<span class="sd">      * Joint probability of observing a pair of ambiguous amino acids is</span>
<span class="sd">        allocated to all potential combinations, e.g. probability of **XX**</span>
<span class="sd">        is allocated to 400 combinations of standard amino acids, similarly</span>
<span class="sd">        probability of **XB** is allocated to 40 combinations of *D* and *N*</span>
<span class="sd">        with the standard amino acids.</span>

<span class="sd">    Selenocysteine (**U**, Sec) and pyrrolysine (**O**, Pyl) are considered</span>
<span class="sd">    as distinct amino acids.  When *ambiguity* is set **False**, all alphabet</span>
<span class="sd">    characters as considered as distinct types.  All non-alphabet characters</span>
<span class="sd">    are considered as gaps.&quot;&quot;&quot;</span>

    <span class="n">msa</span> <span class="o">=</span> <span class="n">getMSA</span><span class="p">(</span><span class="n">msa</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">.msatools</span> <span class="kn">import</span> <span class="n">msasca</span>
    <span class="n">LOGGER</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;_sca&#39;</span><span class="p">)</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">msa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">sca</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">length</span><span class="p">,</span> <span class="n">length</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">sca</span> <span class="o">=</span> <span class="n">msasca</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">sca</span><span class="p">,</span> <span class="n">turbo</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">turbo</span><span class="p">))</span>
    <span class="n">LOGGER</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s1">&#39;SCA matrix was calculated in </span><span class="si">%.2f</span><span class="s1">s.&#39;</span><span class="p">,</span> <span class="s1">&#39;_sca&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">sca</span></div>

<span class="n">buildSCAMatrix</span><span class="o">.</span><span class="vm">__doc__</span> <span class="o">+=</span> <span class="n">doc_turbo</span>

<div class="viewcode-block" id="buildPCMatrix"><a class="viewcode-back" href="../../../manual/reference/sequence/analysis.html#prody.sequence.analysis.buildPCMatrix">[docs]</a><span class="k">def</span> <span class="nf">buildPCMatrix</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">turbo</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns PC matrix calculated for *msa*, which may be an :class:`.MSA`</span>
<span class="sd">    instance or a 2D Numpy character array.</span>

<span class="sd">    Implementation is case insensitive and handles ambiguous amino acids</span>
<span class="sd">    as follows:</span>

<span class="sd">      * **B** (Asx) count is allocated to *D* (Asp) and *N* (Asn)</span>
<span class="sd">      * **Z** (Glx) count is allocated to *E* (Glu) and *Q* (Gln)</span>
<span class="sd">      * **J** (Xle) count is allocated to *I* (Ile) and *L* (Leu)</span>
<span class="sd">      * **X** (Xaa) count is allocated to the twenty standard amino acids</span>
<span class="sd">      * Joint probability of observing a pair of ambiguous amino acids is</span>
<span class="sd">        allocated to all potential combinations, e.g. probability of **XX**</span>
<span class="sd">        is allocated to 400 combinations of standard amino acids, similarly</span>
<span class="sd">        probability of **XB** is allocated to 40 combinations of *D* and *N*</span>
<span class="sd">        with the standard amino acids.</span>

<span class="sd">    Selenocysteine (**U**, Sec) and pyrrolysine (**O**, Pyl) are considered</span>
<span class="sd">    as distinct amino acids.  When *ambiguity* is set **False**, all alphabet</span>
<span class="sd">    characters as considered as distinct types.  All non-alphabet characters</span>
<span class="sd">    are considered as gaps.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">msa</span> <span class="o">=</span> <span class="n">getMSA</span><span class="p">(</span><span class="n">msa</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">.msatools</span> <span class="kn">import</span> <span class="n">msapsicov</span>
    <span class="n">LOGGER</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;_psicov&#39;</span><span class="p">)</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">msa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">pc</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">length</span><span class="p">,</span> <span class="n">length</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
    <span class="n">pc</span> <span class="o">=</span> <span class="n">msapsicov</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">pc</span><span class="p">,</span> <span class="n">turbo</span><span class="o">=</span><span class="nb">bool</span><span class="p">(</span><span class="n">turbo</span><span class="p">))</span>
    <span class="n">LOGGER</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s1">&#39;PC matrix was calculated in </span><span class="si">%.2f</span><span class="s1">s.&#39;</span><span class="p">,</span> <span class="s1">&#39;_psicov&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">pc</span></div>

<div class="viewcode-block" id="buildDirectInfoMatrix"><a class="viewcode-back" href="../../../manual/reference/sequence/analysis.html#prody.sequence.analysis.buildDirectInfoMatrix">[docs]</a><span class="k">def</span> <span class="nf">buildDirectInfoMatrix</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">seqid</span><span class="o">=.</span><span class="mi">8</span><span class="p">,</span> <span class="n">pseudo_weight</span><span class="o">=.</span><span class="mi">5</span><span class="p">,</span> <span class="n">refine</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span>
                          <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns direct information matrix calculated for *msa*, which may be an</span>
<span class="sd">    :class:`.MSA` instance or a 2D Numpy character array.</span>

<span class="sd">    Sequences sharing sequence identity of *seqid* or more with another</span>
<span class="sd">    sequence are regarded as similar sequences for calculating their weights</span>
<span class="sd">    using :func:`.calcMeff`.</span>

<span class="sd">    *pseudo_weight* are the weight for pseudo count probability.</span>

<span class="sd">    Sequences are not refined by default. When *refine* is set **True**,</span>
<span class="sd">    the MSA will be refined by the first sequence and the shape of direct</span>
<span class="sd">    information matrix will be smaller.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">msa</span> <span class="o">=</span> <span class="n">getMSA</span><span class="p">(</span><span class="n">msa</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">.msatools</span> <span class="kn">import</span> <span class="n">msadipretest</span><span class="p">,</span> <span class="n">msadirectinfo1</span><span class="p">,</span> <span class="n">msadirectinfo2</span>
    <span class="kn">from</span> <span class="nn">numpy</span> <span class="kn">import</span> <span class="n">matrix</span>

    <span class="n">LOGGER</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;_di&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">msa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&lt;</span><span class="mi">250</span><span class="p">:</span>
        <span class="n">LOGGER</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;DI performs the best with higher number of sequences, and &#39;</span>
                       <span class="s1">&#39;minimal number of sequences is recommended as 250.&#39;</span><span class="p">)</span>
    <span class="n">refine</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">refine</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="c1"># msadipretest get some parameter from msa to set matrix size</span>
    <span class="n">length</span><span class="p">,</span> <span class="n">q</span> <span class="o">=</span> <span class="n">msadipretest</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">refine</span><span class="o">=</span><span class="n">refine</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="n">matrix</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">matrix</span><span class="p">(</span><span class="n">zeros</span><span class="p">((</span><span class="n">length</span><span class="o">*</span><span class="n">q</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="nb">float</span><span class="p">)),</span>
                   <span class="n">matrix</span><span class="p">(</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">length</span><span class="o">*</span><span class="n">q</span><span class="p">),</span> <span class="nb">float</span><span class="p">)))</span>
    <span class="n">prob</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">length</span><span class="p">,</span> <span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
    <span class="c1"># msadirectinfo1 return c to be inversed and prob to be used</span>
    <span class="n">meff</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">prob</span> <span class="o">=</span> <span class="n">msadirectinfo1</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">prob</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">1.</span><span class="o">-</span><span class="n">seqid</span><span class="p">,</span>
                                              <span class="n">pseudocount_weight</span><span class="o">=</span><span class="n">pseudo_weight</span><span class="p">,</span>
                                              <span class="n">refine</span><span class="o">=</span><span class="n">refine</span><span class="p">,</span> <span class="n">q</span><span class="o">=</span><span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">c</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">I</span>

    <span class="n">di</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">length</span><span class="p">,</span> <span class="n">length</span><span class="p">),</span> <span class="nb">float</span><span class="p">)</span>
    <span class="c1"># get final DI</span>
    <span class="n">di</span> <span class="o">=</span> <span class="n">msadirectinfo2</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">length</span><span class="p">,</span> <span class="n">c</span><span class="p">,</span> <span class="n">prob</span><span class="p">,</span> <span class="n">di</span><span class="p">,</span> <span class="n">q</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">del</span> <span class="n">prob</span><span class="p">,</span> <span class="n">c</span>
    <span class="n">LOGGER</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s1">&#39;DI matrix was calculated in </span><span class="si">%.2f</span><span class="s1">s.&#39;</span><span class="p">,</span> <span class="s1">&#39;_di&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">di</span></div>


<div class="viewcode-block" id="calcMeff"><a class="viewcode-back" href="../../../manual/reference/sequence/analysis.html#prody.sequence.analysis.calcMeff">[docs]</a><span class="k">def</span> <span class="nf">calcMeff</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">seqid</span><span class="o">=.</span><span class="mi">8</span><span class="p">,</span> <span class="n">refine</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="bp">False</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Returns the Meff for *msa*, which may be an :class:`.MSA`</span>
<span class="sd">    instance or a 2D Numpy character array.</span>

<span class="sd">    Since similar sequences in an *msa* decreases the diversity of *msa*,</span>
<span class="sd">    *Meff* gives a weight for sequences in the *msa*.</span>

<span class="sd">    For example: One sequence in MSA has 5 other similar sequences in this</span>
<span class="sd">    MSA(itself included). The weight of this sequence is defined as 1/5=0.2.</span>
<span class="sd">    Meff is the sum of all sequence weights. In another word, Meff can be</span>
<span class="sd">    understood as the effective number of independent sequences.</span>

<span class="sd">    Sequences sharing sequence identity of *seqid* or more with another</span>
<span class="sd">    sequence are regarded as similar sequences to calculate Meff.</span>

<span class="sd">    Sequences are not refined by default. When *refine* is set **True**, the</span>
<span class="sd">    MSA will be refined by the first sequence.</span>

<span class="sd">    The weight for each sequence are returned when *weight* is **True**.&quot;&quot;&quot;</span>

    <span class="n">msa</span> <span class="o">=</span> <span class="n">getMSA</span><span class="p">(</span><span class="n">msa</span><span class="p">)</span>
    <span class="kn">from</span> <span class="nn">.msatools</span> <span class="kn">import</span> <span class="n">msameff</span>
    <span class="n">LOGGER</span><span class="o">.</span><span class="n">timeit</span><span class="p">(</span><span class="s1">&#39;_meff&#39;</span><span class="p">)</span>
    <span class="n">refine</span> <span class="o">=</span> <span class="mi">1</span> <span class="k">if</span> <span class="n">refine</span> <span class="k">else</span> <span class="mi">0</span>
    <span class="n">weight</span> <span class="o">=</span> <span class="mi">0</span> <span class="k">if</span> <span class="n">weight</span> <span class="k">else</span> <span class="mi">1</span>  <span class="c1"># A Mark for return weighted array.</span>
    <span class="k">if</span> <span class="p">(</span><span class="ow">not</span> <span class="n">weight</span><span class="p">):</span>
        <span class="n">w</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">msa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="nb">float</span><span class="p">)</span>
        <span class="n">meff</span> <span class="o">=</span> <span class="n">msameff</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">1.</span><span class="o">-</span><span class="n">seqid</span><span class="p">,</span> <span class="n">meff_only</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span>
                       <span class="n">refine</span><span class="o">=</span><span class="n">refine</span><span class="p">,</span> <span class="n">w</span><span class="o">=</span><span class="n">w</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">meff</span> <span class="o">=</span> <span class="n">msameff</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">theta</span><span class="o">=</span><span class="mf">1.</span><span class="o">-</span><span class="n">seqid</span><span class="p">,</span> <span class="n">meff_only</span><span class="o">=</span><span class="n">weight</span><span class="p">,</span> <span class="n">refine</span><span class="o">=</span><span class="n">refine</span><span class="p">)</span>
    <span class="n">LOGGER</span><span class="o">.</span><span class="n">report</span><span class="p">(</span><span class="s1">&#39;Meff was calculated in </span><span class="si">%.2f</span><span class="s1">s.&#39;</span><span class="p">,</span> <span class="s1">&#39;_meff&#39;</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">meff</span></div>

<span class="k">def</span> <span class="nf">msaeye</span><span class="p">(</span><span class="n">msa</span><span class="p">,</span> <span class="n">unique</span><span class="p">,</span> <span class="n">turbo</span><span class="p">):</span>
    <span class="n">tic1</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
    <span class="n">length</span> <span class="o">=</span> <span class="n">msa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">number</span> <span class="o">=</span> <span class="n">msa</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="c1"># number = 5</span>
    <span class="n">array</span> <span class="o">=</span> <span class="n">eye</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">number</span><span class="p">))</span>

    <span class="n">seqs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">number</span><span class="p">):</span>
        <span class="n">seqs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">msa</span><span class="p">[</span><span class="n">i</span><span class="p">,:])</span>
    <span class="n">iseq</span> <span class="o">=</span> <span class="n">zeros</span><span class="p">((</span><span class="n">number</span><span class="p">,</span> <span class="n">length</span><span class="p">),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">int</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">number</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
                <span class="k">if</span> <span class="nb">ord</span><span class="p">(</span><span class="n">seqs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">90</span><span class="p">:</span>
                    <span class="n">iseq</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="nb">ord</span><span class="p">(</span><span class="n">seqs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">])</span><span class="o">-</span><span class="mi">96</span> <span class="k">if</span> <span class="nb">ord</span><span class="p">(</span><span class="n">seqs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">])</span><span class="o">-</span><span class="mi">96</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">ord</span><span class="p">(</span><span class="n">seqs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">])</span><span class="o">-</span><span class="mi">96</span> <span class="o">&lt;</span> <span class="mi">26</span> <span class="k">else</span> <span class="mi">0</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">iseq</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="nb">ord</span><span class="p">(</span><span class="n">seqs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">])</span><span class="o">-</span><span class="mi">64</span> <span class="k">if</span> <span class="nb">ord</span><span class="p">(</span><span class="n">seqs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">])</span><span class="o">-</span><span class="mi">64</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">ord</span><span class="p">(</span><span class="n">seqs</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">k</span><span class="p">])</span><span class="o">-</span><span class="mi">64</span> <span class="o">&lt;</span> <span class="mi">26</span> <span class="k">else</span> <span class="mi">0</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">number</span><span class="p">):</span>
                <span class="n">score</span><span class="o">=</span><span class="mf">0.</span>
                <span class="n">ncols</span><span class="o">=</span><span class="mf">0.</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
                    <span class="k">if</span> <span class="nb">ord</span><span class="p">(</span><span class="n">seqs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])</span><span class="o">&gt;</span><span class="mi">90</span><span class="p">:</span>
                        <span class="n">iseq</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="nb">ord</span><span class="p">(</span><span class="n">seqs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])</span><span class="o">-</span><span class="mi">96</span> <span class="k">if</span> <span class="nb">ord</span><span class="p">(</span><span class="n">seqs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])</span><span class="o">-</span><span class="mi">96</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">ord</span><span class="p">(</span><span class="n">seqs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])</span><span class="o">-</span><span class="mi">96</span> <span class="o">&lt;</span> <span class="mi">26</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">iseq</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">=</span><span class="nb">ord</span><span class="p">(</span><span class="n">seqs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])</span><span class="o">-</span><span class="mi">64</span> <span class="k">if</span> <span class="nb">ord</span><span class="p">(</span><span class="n">seqs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])</span><span class="o">-</span><span class="mi">64</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="ow">and</span> <span class="nb">ord</span><span class="p">(</span><span class="n">seqs</span><span class="p">[</span><span class="n">j</span><span class="p">][</span><span class="n">k</span><span class="p">])</span><span class="o">-</span><span class="mi">64</span> <span class="o">&lt;</span> <span class="mi">26</span> <span class="k">else</span> <span class="mi">0</span>
                    <span class="k">if</span> <span class="n">iseq</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="ow">or</span> <span class="n">iseq</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]:</span>
                        <span class="n">ncols</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">iseq</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">==</span><span class="n">iseq</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]:</span>
                            <span class="n">score</span><span class="o">+=</span><span class="mi">1</span>
                <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span><span class="nb">float</span><span class="p">(</span><span class="n">score</span><span class="p">)</span><span class="o">/</span><span class="n">ncols</span>
                <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>
            <span class="c1"># print iseq[0]</span>
            <span class="c1"># print seqs[0]</span>
            <span class="c1"># raw_input()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span><span class="n">number</span><span class="p">):</span>
                <span class="n">score</span><span class="o">=</span><span class="mf">0.</span>
                <span class="n">ncols</span><span class="o">=</span><span class="mf">0.</span>
                <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="nb">xrange</span><span class="p">(</span><span class="n">length</span><span class="p">):</span>
                    <span class="k">if</span> <span class="n">iseq</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span> <span class="ow">or</span> <span class="n">iseq</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]:</span>
                        <span class="n">ncols</span> <span class="o">+=</span> <span class="mi">1</span>
                        <span class="k">if</span> <span class="n">iseq</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">k</span><span class="p">]</span><span class="o">==</span><span class="n">iseq</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">k</span><span class="p">]:</span>
                            <span class="n">score</span><span class="o">+=</span><span class="mi">1</span>
                <span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span><span class="o">=</span> <span class="nb">float</span><span class="p">(</span><span class="n">score</span><span class="p">)</span><span class="o">/</span><span class="n">ncols</span><span class="c1">#float(sum((iseq[i] == iseq[j])*(iseq[i]*iseq[j]!=0))) / sum(iseq[i]*iseq[j]!=0)</span>
                <span class="n">array</span><span class="p">[</span><span class="n">j</span><span class="p">,</span><span class="n">i</span><span class="p">]</span><span class="o">=</span><span class="n">array</span><span class="p">[</span><span class="n">i</span><span class="p">,</span><span class="n">j</span><span class="p">]</span>

    <span class="n">toc1</span> <span class="o">=</span> <span class="n">timeit</span><span class="o">.</span><span class="n">default_timer</span><span class="p">()</span>
    <span class="n">elapsed1</span> <span class="o">=</span> <span class="n">toc1</span> <span class="o">-</span> <span class="n">tic1</span>
    <span class="k">print</span><span class="p">(</span><span class="n">elapsed1</span><span class="p">)</span>
</pre></div>

    </div>
  </div>
</div>
<footer class="footer">
  <div class="row">
    <div class="span12">
      <p><small>
      &copy; Copyright 2010-2017, University of Pittsburgh.
      Last updated on Dec 06, 2017.
      Created using <a href="http://sphinx-doc.org">Sphinx</a> 1.3.5.
      </small></p>
    </div>
  </div>
  </div>
</footer>
<div id="codemodal" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
  <div class="modal-header">
    <button type="button" class="close" data-dismiss="modal" aria-hidden="true"></button>
    <h3 id="myModalLabel">Code Snippets</h3>
  </div>
  <div class="modal-body">
    <textarea id="codesnippets"></textarea>
  </div>
  <div class="modal-footer">
    <button class="btn btn-info" id="selectcode">Select Code</button>
    <!--
    <button class="btn btn-success" id="copycode" data-clipboard-target="codesnippets">Copy Code</button>
    -->
    <button class="btn" data-dismiss="modal" aria-hidden="true">Close</button>
  </div>
  <input type="hidden" id="zeroclipboardpath" value="../../../_static/js/zeroclipboard.swf">
</div>
  </body>
</html>